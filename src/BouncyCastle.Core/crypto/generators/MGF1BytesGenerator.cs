using org.bouncycastle.Port;
using org.bouncycastle.Port.java.lang;

namespace org.bouncycastle.crypto.generators
{
	using MGFParameters = org.bouncycastle.crypto.@params.MGFParameters;

	/// <summary>
	/// Generator for MGF1 as defined in PKCS 1v2
	/// </summary>
	public class MGF1BytesGenerator : DerivationFunction
	{
		private Digest digest;
		private byte[] seed;
		private int hLen;

		/// <param name="digest"> the digest to be used as the source of generated bytes </param>
		public MGF1BytesGenerator(Digest digest)
		{
			this.digest = digest;
			this.hLen = digest.getDigestSize();
		}

		public virtual void init(DerivationParameters param)
		{
			if (!(param is MGFParameters))
			{
				throw new IllegalArgumentException("MGF parameters required for MGF1Generator");
			}

			MGFParameters p = (MGFParameters)param;

			seed = p.getSeed();
		}

		/// <summary>
		/// return the underlying digest.
		/// </summary>
		public virtual Digest getDigest()
		{
			return digest;
		}

		/// <summary>
		/// int to octet string.
		/// </summary>
		private void ItoOSP(int i, byte[] sp)
		{
			sp[0] = (byte)((int)((uint)i >> 24));
			sp[1] = (byte)((int)((uint)i >> 16));
			sp[2] = (byte)((int)((uint)i >> 8));
			sp[3] = (byte)((int)((uint)i >> 0));
		}

		/// <summary>
		/// fill len bytes of the output buffer with bytes generated from
		/// the derivation function.
		/// </summary>
		/// <exception cref="DataLengthException"> if the out buffer is too small. </exception>
		public virtual int generateBytes(byte[] @out, int outOff, int len)
		{
			if ((@out.Length - len) < outOff)
			{
				throw new OutputLengthException("output buffer too small");
			}

			byte[] hashBuf = new byte[hLen];
			byte[] C = new byte[4];
			int counter = 0;

			digest.reset();

			if (len > hLen)
			{
				do
				{
					ItoOSP(counter, C);

					digest.update(seed, 0, seed.Length);
					digest.update(C, 0, C.Length);
					digest.doFinal(hashBuf, 0);

					JavaSystem.arraycopy(hashBuf, 0, @out, outOff + counter * hLen, hLen);
				} while (++counter < (len / hLen));
			}

			if ((counter * hLen) < len)
			{
				ItoOSP(counter, C);

				digest.update(seed, 0, seed.Length);
				digest.update(C, 0, C.Length);
				digest.doFinal(hashBuf, 0);

				JavaSystem.arraycopy(hashBuf, 0, @out, outOff + counter * hLen, len - (counter * hLen));
			}

			return len;
		}
	}

}