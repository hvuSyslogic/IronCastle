using org.bouncycastle.Port;
using org.bouncycastle.Port.java.lang;

namespace org.bouncycastle.crypto.agreement.kdf
{
	using KDFParameters = org.bouncycastle.crypto.@params.KDFParameters;

	/// <summary>
	/// Generator for Concatenation Key Derivation Function defined in NIST SP 800-56A, Sect 5.8.1
	/// </summary>
	public class ConcatenationKDFGenerator : DerivationFunction
	{
		private Digest digest;
		private byte[] shared;
		private byte[] otherInfo;
		private int hLen;

		/// <param name="digest"> the digest to be used as the source of generated bytes </param>
		public ConcatenationKDFGenerator(Digest digest)
		{
			this.digest = digest;
			this.hLen = digest.getDigestSize();
		}

		public virtual void init(DerivationParameters param)
		{
			if (param is KDFParameters)
			{
				KDFParameters p = (KDFParameters)param;

				shared = p.getSharedSecret();
				otherInfo = p.getIV();
			}
			else
			{
				throw new IllegalArgumentException("KDF parameters required for generator");
			}
		}

		/// <summary>
		/// return the underlying digest.
		/// </summary>
		public virtual Digest getDigest()
		{
			return digest;
		}

		/// <summary>
		/// int to octet string.
		/// </summary>
		private void ItoOSP(int i, byte[] sp)
		{
			sp[0] = (byte)((int)((uint)i >> 24));
			sp[1] = (byte)((int)((uint)i >> 16));
			sp[2] = (byte)((int)((uint)i >> 8));
			sp[3] = (byte)((int)((uint)i >> 0));
		}

		/// <summary>
		/// fill len bytes of the output buffer with bytes generated from
		/// the derivation function.
		/// </summary>
		/// <exception cref="DataLengthException"> if the out buffer is too small. </exception>
		public virtual int generateBytes(byte[] @out, int outOff, int len)
		{
			if ((@out.Length - len) < outOff)
			{
				throw new OutputLengthException("output buffer too small");
			}

			byte[] hashBuf = new byte[hLen];
			byte[] C = new byte[4];
			int counter = 1;
			int outputLen = 0;

			digest.reset();

			if (len > hLen)
			{
				do
				{
					ItoOSP(counter, C);

					digest.update(C, 0, C.Length);
					digest.update(shared, 0, shared.Length);
					digest.update(otherInfo, 0, otherInfo.Length);

					digest.doFinal(hashBuf, 0);

					JavaSystem.arraycopy(hashBuf, 0, @out, outOff + outputLen, hLen);
					outputLen += hLen;
				} while ((counter++) < (len / hLen));
			}

			if (outputLen < len)
			{
				ItoOSP(counter, C);

				digest.update(C, 0, C.Length);
				digest.update(shared, 0, shared.Length);
				digest.update(otherInfo, 0, otherInfo.Length);

				digest.doFinal(hashBuf, 0);

				JavaSystem.arraycopy(hashBuf, 0, @out, outOff + outputLen, len - outputLen);
			}

			return len;
		}
	}

}