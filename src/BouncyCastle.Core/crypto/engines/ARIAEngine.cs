using org.bouncycastle.crypto.@params;
using org.bouncycastle.Port;
using org.bouncycastle.Port.Extensions;
using org.bouncycastle.Port.java.lang;
using org.bouncycastle.util.encoders;

namespace org.bouncycastle.crypto.engines
{
		
	/// <summary>
	/// RFC 5794.
	/// 
	/// ARIA is a 128-bit block cipher with 128-, 192-, and 256-bit keys.
	/// </summary>
	public class ARIAEngine : BlockCipher
	{
		private static readonly byte[][] C = new byte[][] {Hex.decode("517cc1b727220a94fe13abe8fa9a6ee0"), Hex.decode("6db14acc9e21c820ff28b1d5ef5de2b0"), Hex.decode("db92371d2126e9700324977504e8c90e")};

		private static readonly byte[] SB1_sbox = new byte[] {0x63, 0x7c, 0x77, 0x7b, unchecked(0xf2), 0x6b, 0x6f, unchecked(0xc5), 0x30, 0x01, 0x67, 0x2b, unchecked(0xfe), unchecked(0xd7), unchecked(0xab), 0x76, unchecked(0xca), unchecked(0x82), unchecked(0xc9), 0x7d, unchecked(0xfa), 0x59, 0x47, unchecked(0xf0), unchecked(0xad), unchecked(0xd4), unchecked(0xa2), unchecked(0xaf), unchecked(0x9c), unchecked(0xa4), 0x72, unchecked(0xc0), unchecked(0xb7), unchecked(0xfd), unchecked(0x93), 0x26, 0x36, 0x3f, unchecked(0xf7), unchecked(0xcc), 0x34, unchecked(0xa5), unchecked(0xe5), unchecked(0xf1), 0x71, unchecked(0xd8), 0x31, 0x15, 0x04, unchecked(0xc7), 0x23, unchecked(0xc3), 0x18, unchecked(0x96), 0x05, unchecked(0x9a), 0x07, 0x12, unchecked(0x80), unchecked(0xe2), unchecked(0xeb), 0x27, unchecked(0xb2), 0x75, 0x09, unchecked(0x83), 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, unchecked(0xa0), 0x52, 0x3b, unchecked(0xd6), unchecked(0xb3), 0x29, unchecked(0xe3), 0x2f, unchecked(0x84), 0x53, unchecked(0xd1), 0x00, unchecked(0xed), 0x20, unchecked(0xfc), unchecked(0xb1), 0x5b, 0x6a, unchecked(0xcb), unchecked(0xbe), 0x39, 0x4a, 0x4c, 0x58, unchecked(0xcf), unchecked(0xd0), unchecked(0xef), unchecked(0xaa), unchecked(0xfb), 0x43, 0x4d, 0x33, unchecked(0x85), 0x45, unchecked(0xf9), 0x02, 0x7f, 0x50, 0x3c, unchecked(0x9f), unchecked(0xa8), 0x51, unchecked(0xa3), 0x40, unchecked(0x8f), unchecked(0x92), unchecked(0x9d), 0x38, unchecked(0xf5), unchecked(0xbc), unchecked(0xb6), unchecked(0xda), 0x21, 0x10, unchecked(0xff), unchecked(0xf3), unchecked(0xd2), unchecked(0xcd), 0x0c, 0x13, unchecked(0xec), 0x5f, unchecked(0x97), 0x44, 0x17, unchecked(0xc4), unchecked(0xa7), 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, unchecked(0x81), 0x4f, unchecked(0xdc), 0x22, 0x2a, unchecked(0x90), unchecked(0x88), 0x46, unchecked(0xee), unchecked(0xb8), 0x14, unchecked(0xde), 0x5e, 0x0b, unchecked(0xdb), unchecked(0xe0), 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, unchecked(0xc2), unchecked(0xd3), unchecked(0xac), 0x62, unchecked(0x91), unchecked(0x95), unchecked(0xe4), 0x79, unchecked(0xe7), unchecked(0xc8), 0x37, 0x6d, unchecked(0x8d), unchecked(0xd5), 0x4e, unchecked(0xa9), 0x6c, 0x56, unchecked(0xf4), unchecked(0xea), 0x65, 0x7a, unchecked(0xae), 0x08, unchecked(0xba), 0x78, 0x25, 0x2e, 0x1c, unchecked(0xa6), unchecked(0xb4), unchecked(0xc6), unchecked(0xe8), unchecked(0xdd), 0x74, 0x1f, 0x4b, unchecked(0xbd), unchecked(0x8b), unchecked(0x8a), 0x70, 0x3e, unchecked(0xb5), 0x66, 0x48, 0x03, unchecked(0xf6), 0x0e, 0x61, 0x35, 0x57, unchecked(0xb9), unchecked(0x86), unchecked(0xc1), 0x1d, unchecked(0x9e), unchecked(0xe1), unchecked(0xf8), unchecked(0x98), 0x11, 0x69, unchecked(0xd9), unchecked(0x8e), unchecked(0x94), unchecked(0x9b), 0x1e, unchecked(0x87), unchecked(0xe9), unchecked(0xce), 0x55, 0x28, unchecked(0xdf), unchecked(0x8c), unchecked(0xa1), unchecked(0x89), 0x0d, unchecked(0xbf), unchecked(0xe6), 0x42, 0x68, 0x41, unchecked(0x99), 0x2d, 0x0f, unchecked(0xb0), 0x54, unchecked(0xbb), 0x16};

		private static readonly byte[] SB2_sbox = new byte[] {unchecked(0xe2), 0x4e, 0x54, unchecked(0xfc), unchecked(0x94), unchecked(0xc2), 0x4a, unchecked(0xcc), 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, unchecked(0x8b), unchecked(0xd1), 0x5e, unchecked(0xfa), 0x64, unchecked(0xcb), unchecked(0xb4), unchecked(0x97), unchecked(0xbe), 0x2b, unchecked(0xbc), 0x77, 0x2e, 0x03, unchecked(0xd3), 0x19, 0x59, unchecked(0xc1), 0x1d, 0x06, 0x41, 0x6b, 0x55, unchecked(0xf0), unchecked(0x99), 0x69, unchecked(0xea), unchecked(0x9c), 0x18, unchecked(0xae), 0x63, unchecked(0xdf), unchecked(0xe7), unchecked(0xbb), 0x00, 0x73, 0x66, unchecked(0xfb), unchecked(0x96), 0x4c, unchecked(0x85), unchecked(0xe4), 0x3a, 0x09, 0x45, unchecked(0xaa), 0x0f, unchecked(0xee), 0x10, unchecked(0xeb), 0x2d, 0x7f, unchecked(0xf4), 0x29, unchecked(0xac), unchecked(0xcf), unchecked(0xad), unchecked(0x91), unchecked(0x8d), 0x78, unchecked(0xc8), unchecked(0x95), unchecked(0xf9), 0x2f, unchecked(0xce), unchecked(0xcd), 0x08, 0x7a, unchecked(0x88), 0x38, 0x5c, unchecked(0x83), 0x2a, 0x28, 0x47, unchecked(0xdb), unchecked(0xb8), unchecked(0xc7), unchecked(0x93), unchecked(0xa4), 0x12, 0x53, unchecked(0xff), unchecked(0x87), 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, unchecked(0x8e), 0x37, 0x74, 0x32, unchecked(0xca), unchecked(0xe9), unchecked(0xb1), unchecked(0xb7), unchecked(0xab), 0x0c, unchecked(0xd7), unchecked(0xc4), 0x56, 0x42, 0x26, 0x07, unchecked(0x98), 0x60, unchecked(0xd9), unchecked(0xb6), unchecked(0xb9), 0x11, 0x40, unchecked(0xec), 0x20, unchecked(0x8c), unchecked(0xbd), unchecked(0xa0), unchecked(0xc9), unchecked(0x84), 0x04, 0x49, 0x23, unchecked(0xf1), 0x4f, 0x50, 0x1f, 0x13, unchecked(0xdc), unchecked(0xd8), unchecked(0xc0), unchecked(0x9e), 0x57, unchecked(0xe3), unchecked(0xc3), 0x7b, 0x65, 0x3b, 0x02, unchecked(0x8f), 0x3e, unchecked(0xe8), 0x25, unchecked(0x92), unchecked(0xe5), 0x15, unchecked(0xdd), unchecked(0xfd), 0x17, unchecked(0xa9), unchecked(0xbf), unchecked(0xd4), unchecked(0x9a), 0x7e, unchecked(0xc5), 0x39, 0x67, unchecked(0xfe), 0x76, unchecked(0x9d), 0x43, unchecked(0xa7), unchecked(0xe1), unchecked(0xd0), unchecked(0xf5), 0x68, unchecked(0xf2), 0x1b, 0x34, 0x70, 0x05, unchecked(0xa3), unchecked(0x8a), unchecked(0xd5), 0x79, unchecked(0x86), unchecked(0xa8), 0x30, unchecked(0xc6), 0x51, 0x4b, 0x1e, unchecked(0xa6), 0x27, unchecked(0xf6), 0x35, unchecked(0xd2), 0x6e, 0x24, 0x16, unchecked(0x82), 0x5f, unchecked(0xda), unchecked(0xe6), 0x75, unchecked(0xa2), unchecked(0xef), 0x2c, unchecked(0xb2), 0x1c, unchecked(0x9f), 0x5d, 0x6f, unchecked(0x80), 0x0a, 0x72, 0x44, unchecked(0x9b), 0x6c, unchecked(0x90), 0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, unchecked(0xf3), 0x61, unchecked(0xa1), unchecked(0xf7), unchecked(0xb0), unchecked(0xd6), 0x3f, 0x7c, 0x6d, unchecked(0xed), 0x14, unchecked(0xe0), unchecked(0xa5), 0x3d, 0x22, unchecked(0xb3), unchecked(0xf8), unchecked(0x89), unchecked(0xde), 0x71, 0x1a, unchecked(0xaf), unchecked(0xba), unchecked(0xb5), unchecked(0x81)};

		private static readonly byte[] SB3_sbox = new byte[] {0x52, 0x09, 0x6a, unchecked(0xd5), 0x30, 0x36, unchecked(0xa5), 0x38, unchecked(0xbf), 0x40, unchecked(0xa3), unchecked(0x9e), unchecked(0x81), unchecked(0xf3), unchecked(0xd7), unchecked(0xfb), 0x7c, unchecked(0xe3), 0x39, unchecked(0x82), unchecked(0x9b), 0x2f, unchecked(0xff), unchecked(0x87), 0x34, unchecked(0x8e), 0x43, 0x44, unchecked(0xc4), unchecked(0xde), unchecked(0xe9), unchecked(0xcb), 0x54, 0x7b, unchecked(0x94), 0x32, unchecked(0xa6), unchecked(0xc2), 0x23, 0x3d, unchecked(0xee), 0x4c, unchecked(0x95), 0x0b, 0x42, unchecked(0xfa), unchecked(0xc3), 0x4e, 0x08, 0x2e, unchecked(0xa1), 0x66, 0x28, unchecked(0xd9), 0x24, unchecked(0xb2), 0x76, 0x5b, unchecked(0xa2), 0x49, 0x6d, unchecked(0x8b), unchecked(0xd1), 0x25, 0x72, unchecked(0xf8), unchecked(0xf6), 0x64, unchecked(0x86), 0x68, unchecked(0x98), 0x16, unchecked(0xd4), unchecked(0xa4), 0x5c, unchecked(0xcc), 0x5d, 0x65, unchecked(0xb6), unchecked(0x92), 0x6c, 0x70, 0x48, 0x50, unchecked(0xfd), unchecked(0xed), unchecked(0xb9), unchecked(0xda), 0x5e, 0x15, 0x46, 0x57, unchecked(0xa7), unchecked(0x8d), unchecked(0x9d), unchecked(0x84), unchecked(0x90), unchecked(0xd8), unchecked(0xab), 0x00, unchecked(0x8c), unchecked(0xbc), unchecked(0xd3), 0x0a, unchecked(0xf7), unchecked(0xe4), 0x58, 0x05, unchecked(0xb8), unchecked(0xb3), 0x45, 0x06, unchecked(0xd0), 0x2c, 0x1e, unchecked(0x8f), unchecked(0xca), 0x3f, 0x0f, 0x02, unchecked(0xc1), unchecked(0xaf), unchecked(0xbd), 0x03, 0x01, 0x13, unchecked(0x8a), 0x6b, 0x3a, unchecked(0x91), 0x11, 0x41, 0x4f, 0x67, unchecked(0xdc), unchecked(0xea), unchecked(0x97), unchecked(0xf2), unchecked(0xcf), unchecked(0xce), unchecked(0xf0), unchecked(0xb4), unchecked(0xe6), 0x73, unchecked(0x96), unchecked(0xac), 0x74, 0x22, unchecked(0xe7), unchecked(0xad), 0x35, unchecked(0x85), unchecked(0xe2), unchecked(0xf9), 0x37, unchecked(0xe8), 0x1c, 0x75, unchecked(0xdf), 0x6e, 0x47, unchecked(0xf1), 0x1a, 0x71, 0x1d, 0x29, unchecked(0xc5), unchecked(0x89), 0x6f, unchecked(0xb7), 0x62, 0x0e, unchecked(0xaa), 0x18, unchecked(0xbe), 0x1b, unchecked(0xfc), 0x56, 0x3e, 0x4b, unchecked(0xc6), unchecked(0xd2), 0x79, 0x20, unchecked(0x9a), unchecked(0xdb), unchecked(0xc0), unchecked(0xfe), 0x78, unchecked(0xcd), 0x5a, unchecked(0xf4), 0x1f, unchecked(0xdd), unchecked(0xa8), 0x33, unchecked(0x88), 0x07, unchecked(0xc7), 0x31, unchecked(0xb1), 0x12, 0x10, 0x59, 0x27, unchecked(0x80), unchecked(0xec), 0x5f, 0x60, 0x51, 0x7f, unchecked(0xa9), 0x19, unchecked(0xb5), 0x4a, 0x0d, 0x2d, unchecked(0xe5), 0x7a, unchecked(0x9f), unchecked(0x93), unchecked(0xc9), unchecked(0x9c), unchecked(0xef), unchecked(0xa0), unchecked(0xe0), 0x3b, 0x4d, unchecked(0xae), 0x2a, unchecked(0xf5), unchecked(0xb0), unchecked(0xc8), unchecked(0xeb), unchecked(0xbb), 0x3c, unchecked(0x83), 0x53, unchecked(0x99), 0x61, 0x17, 0x2b, 0x04, 0x7e, unchecked(0xba), 0x77, unchecked(0xd6), 0x26, unchecked(0xe1), 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};

		private static readonly byte[] SB4_sbox = new byte[] {0x30, 0x68, unchecked(0x99), 0x1b, unchecked(0x87), unchecked(0xb9), 0x21, 0x78, 0x50, 0x39, unchecked(0xdb), unchecked(0xe1), 0x72, 0x9, 0x62, 0x3c, 0x3e, 0x7e, 0x5e, unchecked(0x8e), unchecked(0xf1), unchecked(0xa0), unchecked(0xcc), unchecked(0xa3), 0x2a, 0x1d, unchecked(0xfb), unchecked(0xb6), unchecked(0xd6), 0x20, unchecked(0xc4), unchecked(0x8d), unchecked(0x81), 0x65, unchecked(0xf5), unchecked(0x89), unchecked(0xcb), unchecked(0x9d), 0x77, unchecked(0xc6), 0x57, 0x43, 0x56, 0x17, unchecked(0xd4), 0x40, 0x1a, 0x4d, unchecked(0xc0), 0x63, 0x6c, unchecked(0xe3), unchecked(0xb7), unchecked(0xc8), 0x64, 0x6a, 0x53, unchecked(0xaa), 0x38, unchecked(0x98), 0x0c, unchecked(0xf4), unchecked(0x9b), unchecked(0xed), 0x7f, 0x22, 0x76, unchecked(0xaf), unchecked(0xdd), 0x3a, 0x0b, 0x58, 0x67, unchecked(0x88), 0x06, unchecked(0xc3), 0x35, 0x0d, 0x01, unchecked(0x8b), unchecked(0x8c), unchecked(0xc2), unchecked(0xe6), 0x5f, 0x02, 0x24, 0x75, unchecked(0x93), 0x66, 0x1e, unchecked(0xe5), unchecked(0xe2), 0x54, unchecked(0xd8), 0x10, unchecked(0xce), 0x7a, unchecked(0xe8), 0x08, 0x2c, 0x12, unchecked(0x97), 0x32, unchecked(0xab), unchecked(0xb4), 0x27, 0x0a, 0x23, unchecked(0xdf), unchecked(0xef), unchecked(0xca), unchecked(0xd9), unchecked(0xb8), unchecked(0xfa), unchecked(0xdc), 0x31, 0x6b, unchecked(0xd1), unchecked(0xad), 0x19, 0x49, unchecked(0xbd), 0x51, unchecked(0x96), unchecked(0xee), unchecked(0xe4), unchecked(0xa8), 0x41, unchecked(0xda), unchecked(0xff), unchecked(0xcd), 0x55, unchecked(0x86), 0x36, unchecked(0xbe), 0x61, 0x52, unchecked(0xf8), unchecked(0xbb), 0x0e, unchecked(0x82), 0x48, 0x69, unchecked(0x9a), unchecked(0xe0), 0x47, unchecked(0x9e), 0x5c, 0x04, 0x4b, 0x34, 0x15, 0x79, 0x26, unchecked(0xa7), unchecked(0xde), 0x29, unchecked(0xae), unchecked(0x92), unchecked(0xd7), unchecked(0x84), unchecked(0xe9), unchecked(0xd2), unchecked(0xba), 0x5d, unchecked(0xf3), unchecked(0xc5), unchecked(0xb0), unchecked(0xbf), unchecked(0xa4), 0x3b, 0x71, 0x44, 0x46, 0x2b, unchecked(0xfc), unchecked(0xeb), 0x6f, unchecked(0xd5), unchecked(0xf6), 0x14, unchecked(0xfe), 0x7c, 0x70, 0x5a, 0x7d, unchecked(0xfd), 0x2f, 0x18, unchecked(0x83), 0x16, unchecked(0xa5), unchecked(0x91), 0x1f, 0x05, unchecked(0x95), 0x74, unchecked(0xa9), unchecked(0xc1), 0x5b, 0x4a, unchecked(0x85), 0x6d, 0x13, 0x07, 0x4f, 0x4e, 0x45, unchecked(0xb2), 0x0f, unchecked(0xc9), 0x1c, unchecked(0xa6), unchecked(0xbc), unchecked(0xec), 0x73, unchecked(0x90), 0x7b, unchecked(0xcf), 0x59, unchecked(0x8f), unchecked(0xa1), unchecked(0xf9), 0x2d, unchecked(0xf2), unchecked(0xb1), 0x00, unchecked(0x94), 0x37, unchecked(0x9f), unchecked(0xd0), 0x2e, unchecked(0x9c), 0x6e, 0x28, 0x3f, unchecked(0x80), unchecked(0xf0), 0x3d, unchecked(0xd3), 0x25, unchecked(0x8a), unchecked(0xb5), unchecked(0xe7), 0x42, unchecked(0xb3), unchecked(0xc7), unchecked(0xea), unchecked(0xf7), 0x4c, 0x11, 0x33, 0x03, unchecked(0xa2), unchecked(0xac), 0x60};

		protected internal const int BLOCK_SIZE = 16;

		private byte[][] roundKeys;
		//private boolean forEncryption;

		public virtual void init(bool forEncryption, CipherParameters @params)
		{
			if (!(@params is KeyParameter))
			{
				throw new IllegalArgumentException("invalid parameter passed to ARIA init - " + @params.GetType().getName());
			}

			//this.forEncryption = forEncryption;
			this.roundKeys = keySchedule(forEncryption, ((KeyParameter)@params).getKey());
		}

		public virtual string getAlgorithmName()
		{
			return "ARIA";
		}

		public virtual int getBlockSize()
		{
			return BLOCK_SIZE;
		}

		public virtual int processBlock(byte[] @in, int inOff, byte[] @out, int outOff)
		{
			if (roundKeys == null)
			{
				throw new IllegalStateException("ARIA engine not initialised");
			}
			if (inOff > (@in.Length - BLOCK_SIZE))
			{
				throw new DataLengthException("input buffer too short");
			}
			if (outOff > (@out.Length - BLOCK_SIZE))
			{
				throw new OutputLengthException("output buffer too short");
			}

			byte[] z = new byte[BLOCK_SIZE];
			JavaSystem.arraycopy(@in, inOff, z, 0, BLOCK_SIZE);

			int i = 0, rounds = roundKeys.Length - 3;
			while (i < rounds)
			{
				FO(z, roundKeys[i++]);
				FE(z, roundKeys[i++]);
			}

			FO(z, roundKeys[i++]);
			xor(z, roundKeys[i++]);
			SL2(z);
			xor(z, roundKeys[i]);

			JavaSystem.arraycopy(z, 0, @out, outOff, BLOCK_SIZE);

			return BLOCK_SIZE;
		}

		public virtual void reset()
		{
			// Empty
		}

		protected internal static void A(byte[] z)
		{
			byte x0 = z[0], x1 = z[1], x2 = z[2], x3 = z[3], x4 = z[4], x5 = z[5], x6 = z[6], x7 = z[7], x8 = z[8], x9 = z[9], x10 = z[10], x11 = z[11], x12 = z[12], x13 = z[13], x14 = z[14], x15 = z[15];

			z[0] = (byte)(x3 ^ x4 ^ x6 ^ x8 ^ x9 ^ x13 ^ x14);
			z[1] = (byte)(x2 ^ x5 ^ x7 ^ x8 ^ x9 ^ x12 ^ x15);
			z[2] = (byte)(x1 ^ x4 ^ x6 ^ x10 ^ x11 ^ x12 ^ x15);
			z[3] = (byte)(x0 ^ x5 ^ x7 ^ x10 ^ x11 ^ x13 ^ x14);
			z[4] = (byte)(x0 ^ x2 ^ x5 ^ x8 ^ x11 ^ x14 ^ x15);
			z[5] = (byte)(x1 ^ x3 ^ x4 ^ x9 ^ x10 ^ x14 ^ x15);
			z[6] = (byte)(x0 ^ x2 ^ x7 ^ x9 ^ x10 ^ x12 ^ x13);
			z[7] = (byte)(x1 ^ x3 ^ x6 ^ x8 ^ x11 ^ x12 ^ x13);
			z[8] = (byte)(x0 ^ x1 ^ x4 ^ x7 ^ x10 ^ x13 ^ x15);
			z[9] = (byte)(x0 ^ x1 ^ x5 ^ x6 ^ x11 ^ x12 ^ x14);
			z[10] = (byte)(x2 ^ x3 ^ x5 ^ x6 ^ x8 ^ x13 ^ x15);
			z[11] = (byte)(x2 ^ x3 ^ x4 ^ x7 ^ x9 ^ x12 ^ x14);
			z[12] = (byte)(x1 ^ x2 ^ x6 ^ x7 ^ x9 ^ x11 ^ x12);
			z[13] = (byte)(x0 ^ x3 ^ x6 ^ x7 ^ x8 ^ x10 ^ x13);
			z[14] = (byte)(x0 ^ x3 ^ x4 ^ x5 ^ x9 ^ x11 ^ x14);
			z[15] = (byte)(x1 ^ x2 ^ x4 ^ x5 ^ x8 ^ x10 ^ x15);
		}

		protected internal static void FE(byte[] D, byte[] RK)
		{
			xor(D, RK);
			SL2(D);
			A(D);
		}

		protected internal static void FO(byte[] D, byte[] RK)
		{
			xor(D, RK);
			SL1(D);
			A(D);
		}

		protected internal static byte[][] keySchedule(bool forEncryption, byte[] K)
		{
			int keyLen = K.Length;
			if (keyLen < 16 || keyLen > 32 || (keyLen & 7) != 0)
			{
				throw new IllegalArgumentException("Key length not 128/192/256 bits.");
			}

			int keyLenIdx = ((int)((uint)keyLen >> 3)) - 2;

			byte[] CK1 = C[keyLenIdx];
			byte[] CK2 = C[(keyLenIdx + 1) % 3];
			byte[] CK3 = C[(keyLenIdx + 2) % 3];

			byte[] KL = new byte[16], KR = new byte[16];
			JavaSystem.arraycopy(K, 0, KL, 0, 16);
			JavaSystem.arraycopy(K, 16, KR, 0, keyLen - 16);

			byte[] W0 = new byte[16];
			byte[] W1 = new byte[16];
			byte[] W2 = new byte[16];
			byte[] W3 = new byte[16];

			JavaSystem.arraycopy(KL, 0, W0, 0, 16);

			JavaSystem.arraycopy(W0, 0, W1, 0, 16);
			FO(W1, CK1);
			xor(W1, KR);

			JavaSystem.arraycopy(W1, 0, W2, 0, 16);
			FE(W2, CK2);
			xor(W2, W0);

			JavaSystem.arraycopy(W2, 0, W3, 0, 16);
			FO(W3, CK3);
			xor(W3, W1);

			int numRounds = 12 + (keyLenIdx * 2);
			byte[][] rks = RectangularArrays.ReturnRectangularSbyteArray(numRounds + 1, 16);

			keyScheduleRound(rks[0], W0, W1, 19);
			keyScheduleRound(rks[1], W1, W2, 19);
			keyScheduleRound(rks[2], W2, W3, 19);
			keyScheduleRound(rks[3], W3, W0, 19);

			keyScheduleRound(rks[4], W0, W1, 31);
			keyScheduleRound(rks[5], W1, W2, 31);
			keyScheduleRound(rks[6], W2, W3, 31);
			keyScheduleRound(rks[7], W3, W0, 31);

			keyScheduleRound(rks[8], W0, W1, 67);
			keyScheduleRound(rks[9], W1, W2, 67);
			keyScheduleRound(rks[10], W2, W3, 67);
			keyScheduleRound(rks[11], W3, W0, 67);

			keyScheduleRound(rks[12], W0, W1, 97);
			if (numRounds > 12)
			{
				keyScheduleRound(rks[13], W1, W2, 97);
				keyScheduleRound(rks[14], W2, W3, 97);
				if (numRounds > 14)
				{
					keyScheduleRound(rks[15], W3, W0, 97);

					keyScheduleRound(rks[16], W0, W1, 109);
				}
			}

			if (!forEncryption)
			{
				reverseKeys(rks);

				for (int i = 1; i < numRounds; ++i)
				{
					A(rks[i]);
				}
			}

			return rks;
		}

		protected internal static void keyScheduleRound(byte[] rk, byte[] w, byte[] wr, int n)
		{
			int off = (int)((uint)n >> 3), right = n & 7, left = 8 - right;

			int hi = wr[15 - off] & 0xFF;

			for (int to = 0; to < 16; ++to)
			{
				int lo = wr[(to - off) & 0xF] & 0xFF;

				int b = (hi << left) | ((int)((uint)lo >> right));
				b ^= (w[to] & 0xFF);

				rk[to] = (byte)b;

				hi = lo;
			}
		}

		protected internal static void reverseKeys(byte[][] keys)
		{
			int length = keys.Length, limit = length / 2, last = length - 1;
			for (int i = 0; i < limit; ++i)
			{
				byte[] t = keys[i];
				keys[i] = keys[last - i];
				keys[last - i] = t;
			}
		}

		protected internal static byte SB1(byte x)
		{
			return SB1_sbox[x & 0xFF];
		}

		protected internal static byte SB2(byte x)
		{
			return SB2_sbox[x & 0xFF];
		}

		protected internal static byte SB3(byte x)
		{
			return SB3_sbox[x & 0xFF];
		}

		protected internal static byte SB4(byte x)
		{
			return SB4_sbox[x & 0xFF];
		}

		protected internal static void SL1(byte[] z)
		{
			z[0] = SB1(z[0]);
			z[1] = SB2(z[1]);
			z[2] = SB3(z[2]);
			z[3] = SB4(z[3]);
			z[4] = SB1(z[4]);
			z[5] = SB2(z[5]);
			z[6] = SB3(z[6]);
			z[7] = SB4(z[7]);
			z[8] = SB1(z[8]);
			z[9] = SB2(z[9]);
			z[10] = SB3(z[10]);
			z[11] = SB4(z[11]);
			z[12] = SB1(z[12]);
			z[13] = SB2(z[13]);
			z[14] = SB3(z[14]);
			z[15] = SB4(z[15]);
		}

		protected internal static void SL2(byte[] z)
		{
			z[0] = SB3(z[0]);
			z[1] = SB4(z[1]);
			z[2] = SB1(z[2]);
			z[3] = SB2(z[3]);
			z[4] = SB3(z[4]);
			z[5] = SB4(z[5]);
			z[6] = SB1(z[6]);
			z[7] = SB2(z[7]);
			z[8] = SB3(z[8]);
			z[9] = SB4(z[9]);
			z[10] = SB1(z[10]);
			z[11] = SB2(z[11]);
			z[12] = SB3(z[12]);
			z[13] = SB4(z[13]);
			z[14] = SB1(z[14]);
			z[15] = SB2(z[15]);
		}

		protected internal static void xor(byte[] z, byte[] x)
		{
			for (int i = 0; i < 16; ++i)
			{
				z[i] ^= x[i];
			}
		}
	}

}