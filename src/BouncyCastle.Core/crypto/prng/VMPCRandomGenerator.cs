namespace org.bouncycastle.crypto.prng
{
	using Pack = org.bouncycastle.util.Pack;

	public class VMPCRandomGenerator : RandomGenerator
	{
		private byte n = 0;

		/// <summary>
		/// Permutation generated by code: <code>
		/// // First 1850 fractional digit of Pi number. 
		/// byte[] key = new BigInteger("14159265358979323846...5068006422512520511").toByteArray();
		/// s = 0;
		/// P = new byte[256];
		/// for (int i = 0; i < 256; i++) {
		///     P[i] = (byte) i;
		/// }
		/// for (int m = 0; m < 768; m++) {
		///     s = P[(s + P[m & 0xff] + key[m % key.length]) & 0xff];
		///     byte temp = P[m & 0xff];
		///     P[m & 0xff] = P[s & 0xff];
		///     P[s & 0xff] = temp;
		/// } </code>
		/// </summary>
		private byte[] P = new byte[] {unchecked(0xbb), 0x2c, 0x62, 0x7f, unchecked(0xb5), unchecked(0xaa), unchecked(0xd4), 0x0d, unchecked(0x81), unchecked(0xfe), unchecked(0xb2), unchecked(0x82), unchecked(0xcb), unchecked(0xa0), unchecked(0xa1), 0x08, 0x18, 0x71, 0x56, unchecked(0xe8), 0x49, 0x02, 0x10, unchecked(0xc4), unchecked(0xde), 0x35, unchecked(0xa5), unchecked(0xec), unchecked(0x80), 0x12, unchecked(0xb8), 0x69, unchecked(0xda), 0x2f, 0x75, unchecked(0xcc), unchecked(0xa2), 0x09, 0x36, 0x03, 0x61, 0x2d, unchecked(0xfd), unchecked(0xe0), unchecked(0xdd), 0x05, 0x43, unchecked(0x90), unchecked(0xad), unchecked(0xc8), unchecked(0xe1), unchecked(0xaf), 0x57, unchecked(0x9b), 0x4c, unchecked(0xd8), 0x51, unchecked(0xae), 0x50, unchecked(0x85), 0x3c, 0x0a, unchecked(0xe4), unchecked(0xf3), unchecked(0x9c), 0x26, 0x23, 0x53, unchecked(0xc9), unchecked(0x83), unchecked(0x97), 0x46, unchecked(0xb1), unchecked(0x99), 0x64, 0x31, 0x77, unchecked(0xd5), 0x1d, unchecked(0xd6), 0x78, unchecked(0xbd), 0x5e, unchecked(0xb0), unchecked(0x8a), 0x22, 0x38, unchecked(0xf8), 0x68, 0x2b, 0x2a, unchecked(0xc5), unchecked(0xd3), unchecked(0xf7), unchecked(0xbc), 0x6f, unchecked(0xdf), 0x04, unchecked(0xe5), unchecked(0x95), 0x3e, 0x25, unchecked(0x86), unchecked(0xa6), 0x0b, unchecked(0x8f), unchecked(0xf1), 0x24, 0x0e, unchecked(0xd7), 0x40, unchecked(0xb3), unchecked(0xcf), 0x7e, 0x06, 0x15, unchecked(0x9a), 0x4d, 0x1c, unchecked(0xa3), unchecked(0xdb), 0x32, unchecked(0x92), 0x58, 0x11, 0x27, unchecked(0xf4), 0x59, unchecked(0xd0), 0x4e, 0x6a, 0x17, 0x5b, unchecked(0xac), unchecked(0xff), 0x07, unchecked(0xc0), 0x65, 0x79, unchecked(0xfc), unchecked(0xc7), unchecked(0xcd), 0x76, 0x42, 0x5d, unchecked(0xe7), 0x3a, 0x34, 0x7a, 0x30, 0x28, 0x0f, 0x73, 0x01, unchecked(0xf9), unchecked(0xd1), unchecked(0xd2), 0x19, unchecked(0xe9), unchecked(0x91), unchecked(0xb9), 0x5a, unchecked(0xed), 0x41, 0x6d, unchecked(0xb4), unchecked(0xc3), unchecked(0x9e), unchecked(0xbf), 0x63, unchecked(0xfa), 0x1f, 0x33, 0x60, 0x47, unchecked(0x89), unchecked(0xf0), unchecked(0x96), 0x1a, 0x5f, unchecked(0x93), 0x3d, 0x37, 0x4b, unchecked(0xd9), unchecked(0xa8), unchecked(0xc1), 0x1b, unchecked(0xf6), 0x39, unchecked(0x8b), unchecked(0xb7), 0x0c, 0x20, unchecked(0xce), unchecked(0x88), 0x6e, unchecked(0xb6), 0x74, unchecked(0x8e), unchecked(0x8d), 0x16, 0x29, unchecked(0xf2), unchecked(0x87), unchecked(0xf5), unchecked(0xeb), 0x70, unchecked(0xe3), unchecked(0xfb), 0x55, unchecked(0x9f), unchecked(0xc6), 0x44, 0x4a, 0x45, 0x7d, unchecked(0xe2), 0x6b, 0x5c, 0x6c, 0x66, unchecked(0xa9), unchecked(0x8c), unchecked(0xee), unchecked(0x84), 0x13, unchecked(0xa7), 0x1e, unchecked(0x9d), unchecked(0xdc), 0x67, 0x48, unchecked(0xba), 0x2e, unchecked(0xe6), unchecked(0xa4), unchecked(0xab), 0x7c, unchecked(0x94), 0x00, 0x21, unchecked(0xef), unchecked(0xea), unchecked(0xbe), unchecked(0xca), 0x72, 0x4f, 0x52, unchecked(0x98), 0x3f, unchecked(0xc2), 0x14, 0x7b, 0x3b, 0x54};

		/// <summary>
		/// Value generated in the same way as <seealso cref="VMPCRandomGenerator#P"/>;
		/// </summary>
		private byte s = unchecked(0xbe);

		public VMPCRandomGenerator()
		{
		}

		public virtual void addSeedMaterial(byte[] seed)
		{
			for (int m = 0; m < seed.Length; m++)
			{
				s = P[(s + P[n & 0xff] + seed[m]) & 0xff];
				byte temp = P[n & 0xff];
				P[n & 0xff] = P[s & 0xff];
				P[s & 0xff] = temp;
				n = unchecked((byte)((n + 1) & 0xff));
			}
		}

		public virtual void addSeedMaterial(long seed)
		{
			addSeedMaterial(Pack.longToBigEndian(seed));
		}

		public virtual void nextBytes(byte[] bytes)
		{
			nextBytes(bytes, 0, bytes.Length);
		}

		public virtual void nextBytes(byte[] bytes, int start, int len)
		{
			lock (P)
			{
				int end = start + len;
				for (int i = start; i != end; i++)
				{
					s = P[(s + P[n & 0xff]) & 0xff];
					bytes[i] = P[(P[(P[s & 0xff]) & 0xff] + 1) & 0xff];
					byte temp = P[n & 0xff];
					P[n & 0xff] = P[s & 0xff];
					P[s & 0xff] = temp;
					n = unchecked((byte)((n + 1) & 0xff));
				}
			}
		}
	}

}