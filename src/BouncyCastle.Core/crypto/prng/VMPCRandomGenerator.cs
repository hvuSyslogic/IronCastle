namespace org.bouncycastle.crypto.prng
{
	using Pack = org.bouncycastle.util.Pack;

	public class VMPCRandomGenerator : RandomGenerator
	{
		private byte n = 0;

		/// <summary>
		/// Permutation generated by code: <code>
		/// // First 1850 fractional digit of Pi number. 
		/// byte[] key = new BigInteger("14159265358979323846...5068006422512520511").toByteArray();
		/// s = 0;
		/// P = new byte[256];
		/// for (int i = 0; i < 256; i++) {
		///     P[i] = (byte) i;
		/// }
		/// for (int m = 0; m < 768; m++) {
		///     s = P[(s + P[m & 0xff] + key[m % key.length]) & 0xff];
		///     byte temp = P[m & 0xff];
		///     P[m & 0xff] = P[s & 0xff];
		///     P[s & 0xff] = temp;
		/// } </code>
		/// </summary>
		private byte[] P = new byte[] {unchecked((byte) 0xbb), (byte) 0x2c, (byte) 0x62, (byte) 0x7f, unchecked((byte) 0xb5), unchecked((byte) 0xaa), unchecked((byte) 0xd4), (byte) 0x0d, unchecked((byte) 0x81), unchecked((byte) 0xfe), unchecked((byte) 0xb2), unchecked((byte) 0x82), unchecked((byte) 0xcb), unchecked((byte) 0xa0), unchecked((byte) 0xa1), (byte) 0x08, (byte) 0x18, (byte) 0x71, (byte) 0x56, unchecked((byte) 0xe8), (byte) 0x49, (byte) 0x02, (byte) 0x10, unchecked((byte) 0xc4), unchecked((byte) 0xde), (byte) 0x35, unchecked((byte) 0xa5), unchecked((byte) 0xec), unchecked((byte) 0x80), (byte) 0x12, unchecked((byte) 0xb8), (byte) 0x69, unchecked((byte) 0xda), (byte) 0x2f, (byte) 0x75, unchecked((byte) 0xcc), unchecked((byte) 0xa2), (byte) 0x09, (byte) 0x36, (byte) 0x03, (byte) 0x61, (byte) 0x2d, unchecked((byte) 0xfd), unchecked((byte) 0xe0), unchecked((byte) 0xdd), (byte) 0x05, (byte) 0x43, unchecked((byte) 0x90), unchecked((byte) 0xad), unchecked((byte) 0xc8), unchecked((byte) 0xe1), unchecked((byte) 0xaf), (byte) 0x57, unchecked((byte) 0x9b), (byte) 0x4c, unchecked((byte) 0xd8), (byte) 0x51, unchecked((byte) 0xae), (byte) 0x50, unchecked((byte) 0x85), (byte) 0x3c, (byte) 0x0a, unchecked((byte) 0xe4), unchecked((byte) 0xf3), unchecked((byte) 0x9c), (byte) 0x26, (byte) 0x23, (byte) 0x53, unchecked((byte) 0xc9), unchecked((byte) 0x83), unchecked((byte) 0x97), (byte) 0x46, unchecked((byte) 0xb1), unchecked((byte) 0x99), (byte) 0x64, (byte) 0x31, (byte) 0x77, unchecked((byte) 0xd5), (byte) 0x1d, unchecked((byte) 0xd6), (byte) 0x78, unchecked((byte) 0xbd), (byte) 0x5e, unchecked((byte) 0xb0), unchecked((byte) 0x8a), (byte) 0x22, (byte) 0x38, unchecked((byte) 0xf8), (byte) 0x68, (byte) 0x2b, (byte) 0x2a, unchecked((byte) 0xc5), unchecked((byte) 0xd3), unchecked((byte) 0xf7), unchecked((byte) 0xbc), (byte) 0x6f, unchecked((byte) 0xdf), (byte) 0x04, unchecked((byte) 0xe5), unchecked((byte) 0x95), (byte) 0x3e, (byte) 0x25, unchecked((byte) 0x86), unchecked((byte) 0xa6), (byte) 0x0b, unchecked((byte) 0x8f), unchecked((byte) 0xf1), (byte) 0x24, (byte) 0x0e, unchecked((byte) 0xd7), (byte) 0x40, unchecked((byte) 0xb3), unchecked((byte) 0xcf), (byte) 0x7e, (byte) 0x06, (byte) 0x15, unchecked((byte) 0x9a), (byte) 0x4d, (byte) 0x1c, unchecked((byte) 0xa3), unchecked((byte) 0xdb), (byte) 0x32, unchecked((byte) 0x92), (byte) 0x58, (byte) 0x11, (byte) 0x27, unchecked((byte) 0xf4), (byte) 0x59, unchecked((byte) 0xd0), (byte) 0x4e, (byte) 0x6a, (byte) 0x17, (byte) 0x5b, unchecked((byte) 0xac), unchecked((byte) 0xff), (byte) 0x07, unchecked((byte) 0xc0), (byte) 0x65, (byte) 0x79, unchecked((byte) 0xfc), unchecked((byte) 0xc7), unchecked((byte) 0xcd), (byte) 0x76, (byte) 0x42, (byte) 0x5d, unchecked((byte) 0xe7), (byte) 0x3a, (byte) 0x34, (byte) 0x7a, (byte) 0x30, (byte) 0x28, (byte) 0x0f, (byte) 0x73, (byte) 0x01, unchecked((byte) 0xf9), unchecked((byte) 0xd1), unchecked((byte) 0xd2), (byte) 0x19, unchecked((byte) 0xe9), unchecked((byte) 0x91), unchecked((byte) 0xb9), (byte) 0x5a, unchecked((byte) 0xed), (byte) 0x41, (byte) 0x6d, unchecked((byte) 0xb4), unchecked((byte) 0xc3), unchecked((byte) 0x9e), unchecked((byte) 0xbf), (byte) 0x63, unchecked((byte) 0xfa), (byte) 0x1f, (byte) 0x33, (byte) 0x60, (byte) 0x47, unchecked((byte) 0x89), unchecked((byte) 0xf0), unchecked((byte) 0x96), (byte) 0x1a, (byte) 0x5f, unchecked((byte) 0x93), (byte) 0x3d, (byte) 0x37, (byte) 0x4b, unchecked((byte) 0xd9), unchecked((byte) 0xa8), unchecked((byte) 0xc1), (byte) 0x1b, unchecked((byte) 0xf6), (byte) 0x39, unchecked((byte) 0x8b), unchecked((byte) 0xb7), (byte) 0x0c, (byte) 0x20, unchecked((byte) 0xce), unchecked((byte) 0x88), (byte) 0x6e, unchecked((byte) 0xb6), (byte) 0x74, unchecked((byte) 0x8e), unchecked((byte) 0x8d), (byte) 0x16, (byte) 0x29, unchecked((byte) 0xf2), unchecked((byte) 0x87), unchecked((byte) 0xf5), unchecked((byte) 0xeb), (byte) 0x70, unchecked((byte) 0xe3), unchecked((byte) 0xfb), (byte) 0x55, unchecked((byte) 0x9f), unchecked((byte) 0xc6), (byte) 0x44, (byte) 0x4a, (byte) 0x45, (byte) 0x7d, unchecked((byte) 0xe2), (byte) 0x6b, (byte) 0x5c, (byte) 0x6c, (byte) 0x66, unchecked((byte) 0xa9), unchecked((byte) 0x8c), unchecked((byte) 0xee), unchecked((byte) 0x84), (byte) 0x13, unchecked((byte) 0xa7), (byte) 0x1e, unchecked((byte) 0x9d), unchecked((byte) 0xdc), (byte) 0x67, (byte) 0x48, unchecked((byte) 0xba), (byte) 0x2e, unchecked((byte) 0xe6), unchecked((byte) 0xa4), unchecked((byte) 0xab), (byte) 0x7c, unchecked((byte) 0x94), (byte) 0x00, (byte) 0x21, unchecked((byte) 0xef), unchecked((byte) 0xea), unchecked((byte) 0xbe), unchecked((byte) 0xca), (byte) 0x72, (byte) 0x4f, (byte) 0x52, unchecked((byte) 0x98), (byte) 0x3f, unchecked((byte) 0xc2), (byte) 0x14, (byte) 0x7b, (byte) 0x3b, (byte) 0x54};

		/// <summary>
		/// Value generated in the same way as <seealso cref="VMPCRandomGenerator#P"/>;
		/// </summary>
		private byte s = unchecked((byte) 0xbe);

		public VMPCRandomGenerator()
		{
		}

		public virtual void addSeedMaterial(byte[] seed)
		{
			for (int m = 0; m < seed.Length; m++)
			{
				s = P[(s + P[n & 0xff] + seed[m]) & 0xff];
				byte temp = P[n & 0xff];
				P[n & 0xff] = P[s & 0xff];
				P[s & 0xff] = temp;
				n = unchecked((byte)((n + 1) & 0xff));
			}
		}

		public virtual void addSeedMaterial(long seed)
		{
			addSeedMaterial(Pack.longToBigEndian(seed));
		}

		public virtual void nextBytes(byte[] bytes)
		{
			nextBytes(bytes, 0, bytes.Length);
		}

		public virtual void nextBytes(byte[] bytes, int start, int len)
		{
			lock (P)
			{
				int end = start + len;
				for (int i = start; i != end; i++)
				{
					s = P[(s + P[n & 0xff]) & 0xff];
					bytes[i] = P[(P[(P[s & 0xff]) & 0xff] + 1) & 0xff];
					byte temp = P[n & 0xff];
					P[n & 0xff] = P[s & 0xff];
					P[s & 0xff] = temp;
					n = unchecked((byte)((n + 1) & 0xff));
				}
			}
		}
	}

}