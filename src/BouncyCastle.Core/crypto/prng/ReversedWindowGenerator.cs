using org.bouncycastle.Port.java.lang;

namespace org.bouncycastle.crypto.prng
{
	/// <summary>
	/// Takes bytes generated by an underling RandomGenerator and reverses the order in
	/// each small window (of configurable size).
	/// <para>
	/// Access to internals is synchronized so a single one of these can be shared.
	/// </para>
	/// </summary>
	public class ReversedWindowGenerator : RandomGenerator
	{
		private readonly RandomGenerator generator;

		private byte[] window;
		private int windowCount;

		public ReversedWindowGenerator(RandomGenerator generator, int windowSize)
		{
			if (generator == null)
			{
				throw new IllegalArgumentException("generator cannot be null");
			}
			if (windowSize < 2)
			{
				throw new IllegalArgumentException("windowSize must be at least 2");
			}

			this.generator = generator;
			this.window = new byte[windowSize];
		}

		/// <summary>
		/// Add more seed material to the generator.
		/// </summary>
		/// <param name="seed"> a byte array to be mixed into the generator's state. </param>
		public virtual void addSeedMaterial(byte[] seed)
		{
			lock (this)
			{
				windowCount = 0;
				generator.addSeedMaterial(seed);
			}
		}

		/// <summary>
		/// Add more seed material to the generator.
		/// </summary>
		/// <param name="seed"> a long value to be mixed into the generator's state. </param>
		public virtual void addSeedMaterial(long seed)
		{
			lock (this)
			{
				windowCount = 0;
				generator.addSeedMaterial(seed);
			}
		}

		/// <summary>
		/// Fill bytes with random values.
		/// </summary>
		/// <param name="bytes"> byte array to be filled. </param>
		public virtual void nextBytes(byte[] bytes)
		{
			doNextBytes(bytes, 0, bytes.Length);
		}

		/// <summary>
		/// Fill part of bytes with random values.
		/// </summary>
		/// <param name="bytes"> byte array to be filled. </param>
		/// <param name="start"> index to start filling at. </param>
		/// <param name="len"> length of segment to fill. </param>
		public virtual void nextBytes(byte[] bytes, int start, int len)
		{
			doNextBytes(bytes, start, len);
		}

		private void doNextBytes(byte[] bytes, int start, int len)
		{
			lock (this)
			{
				int done = 0;
				while (done < len)
				{
					if (windowCount < 1)
					{
						generator.nextBytes(window, 0, window.Length);
						windowCount = window.Length;
					}

					bytes[start + done++] = window[--windowCount];
				}
			}
		}
	}

}